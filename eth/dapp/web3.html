<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./js/web3.min.js"></script>
  </head>
  <style>
    .Block {
      width: 100%;

      display: flex;
      flex: 1;
    }
    #blockStore {
      flex-basis: 200px;
      width: 100px;
    }
    #blockDataStore {
      overflow: auto;
      flex: 1;
      overflow: auto;
    }
    #statusBar {
      position: absolute;
      right: 0;
      top: 10px;
    }
  </style>
  <body>
    <div class="Block">
      <!-- <textarea name="" id="blockStore" cols="300" rows="300"></textarea> -->
      <div id="statusBar"></div>
      <div name="" id="blockDataStore"></div>
    </div>

    <script>
   
      const events = {
        events: {},
        on(name, fn) {
          this.events[name] = this.events[name] || [];
          this.events[name].push({ name, fn });
        },
        emit(name, ...arg) {
          if (this.events[name] && this.events[name].length) {
            // while (this.events[name].length) {
              const tasks = this.events[name] || [];
              // console.log(tasks)
              tasks.forEach(({ fn, name }) => {
                fn.call(this, ...arg);
              });
            // }
          }
        },
      };
      const _Promise = (function () {
        const list = [];
        const task_list = 10;
        async function start() {
          if (!list.length) await new Promise((resolve) => setTimeout(resolve, 3000));

          const tasks = list.splice(0, task_list);
          let progress = {
            total: tasks.length,
            progress: 0,
            errorCount: 0,
          };
          console.log("tasks", tasks, list);
          events.emit("fetch_progress", progress);
          await Promise.all(
            tasks.map(({ fn, arg, resolve, reject }) => {
              return fn
                .apply(this, arg)
                .then((res) => {
                  progress.progress=progress.progress+1
                  events.emit("fetch_progress", progress);
                  resolve(res);
                })
                .catch((err) => {
                  progress.progress=progress.progress+1
                  progress.errorCount=progress.errorCount+1
                  events.emit("fetch_progress", progress);
                  resolve(err);
                });
            })
          );

          start();
        }
        start();
        return (fn, ...arg) => {
          return new Promise((resolve, reject) => {
            list.push({
              fn,
              arg,
              resolve,
              reject,
            });
          });
        };
      })();

      class Subscribe {
        constructor(rpcUrl) {
          this.web3 = new Web3(rpcUrl);
          this.blockStore = this._observer({
            blocks: [],
          });

          this.blockStore.subscribe((state) => {
            console.log("state", state);

            document.querySelector("#blockDataStore").innerHTML = `
              <ul>
                  ${state.blocks.map(
                    (v) =>
                      `<li>
                        <h3>blockNumber:${v.num}:${v.status}</h3>
                        <h3>:${(v.data.transactions || []).length}</h3>
                          <textarea cols="300" rows="100" > ${JSON.stringify(v.data, null, 2)}</textarea>
                        </li>`
                  )}
              </ul>
            `;
          });
          events.on("fetch_progress", function ({ progress, errorCount, total }) {
            console.log({ progress, errorCount, total });
            document.querySelector("#statusBar").innerHTML = `
                 <span>error:${errorCount}</span>
                 <span>total:${total}</span>
                 <progress value="${progress}"  max='${total}'></progress>
              `;
          });

          this.transactionsStore = this._observer({});

          // this.transactionsStore.subscribe((state) => {
          //   document.querySelector("#transactionsStore").value = JSON.stringify(state, null, 2);
          // });
          this.init();
        }

        async init() {
          // this.blockStore.state.nodeInfo = await this.web3.eth.getNodeInfo();
          this.getBlockNumberList();
          this.getBlockNumberData();

          this.getTransactionData();

          // this.blockStore.state.gasfee = await this.getFee();

          // this.transactionsStore.state.pendingTransactions = await this.web3.eth.getPendingTransactions();
          // this.transactionsStore.state.transactionFromBlock = await this.web3.eth.getTransactionFromBlock(this.blockStore.state.blockNumber, 2);

          console.log(this.blockStore.state, this.transactionsStore.state);
        }

        async getBlockNumberList() {
          try {
            const blocks = this.blockStore.state.blocks;
            const lastBlock = blocks[blocks.length - 1];
            const newBlockNum = await _Promise(this.web3.eth.getBlockNumber);

            if (lastBlock && newBlockNum - lastBlock.num - 1) {
              new Array(newBlockNum - lastBlock.num - 1).fill(1).map((v, i) => {
                blocks["push"]({
                  num: lastBlockNumber + i + 1,
                  status: 0,
                  data: {},
                });
              });
            }

            if (blocks.find(({ num }) => num == newBlockNum)) {
              this.blockStore.state.blocks = blocks;
              return this.getBlockNumberList();
            }
            blocks.push({
              num: newBlockNum,
              status: 0,
              data: {},
            });
            this.blockStore.state.blocks = blocks;
          } catch (error) {}
          return this.getBlockNumberList();
        }
        async getBlockNumberData() {
          const index = this.blockStore.state.blocks.findIndex((v) => v.status == 0);

          if (index != -1) {
            const blockData = this.blockStore.state.blocks[index];
            blockData.status = 1;
            try {
              blockData.data = await _Promise(this.web3.eth.getBlock, blockData.num);
              blockData.status = 2;
            } catch (error) {
              blockData.status = 3;
            }
            this.blockStore.state.blocks[index] = blockData;
          } else {
            await new Promise((res) => setTimeout(res, 1000));
          }
          // await new Promise((res) => setTimeout(res, 5000));
          return this.getBlockNumberData();
        }

        async getTransactionData() {
          const index = this.blockStore.state.blocks.findIndex((v) => v.status == 2 && (v.data.transactions || []).find((v) => typeof v == "string"));

          if (index != -1) {
            const blockData = this.blockStore.state.blocks[index];

            blockData.data.transactions = await Promise.all(blockData.data.transactions.map((v) => _Promise(this.web3.eth.getTransaction, v)));
            this.blockStore.state.blocks[index] = blockData;
          } else {
            await new Promise((res) => setTimeout(res, 1000));
          }

          this.getTransactionData();
        }
        async getFee() {
          return {
            gasPrice: await _Promise(this.web3.eth.getGasPrice),
          };
        }

        _observer(obj) {
          var queueObserver = new Set();
          return {
            state: new Proxy(obj, {
              set(traget, key, value, target) {
                var result = Reflect.set(...arguments);
                queueObserver.forEach((fn) => fn(traget, obj));
                return result;
              },
            }),
            subscribe(fn) {
              queueObserver.add(fn);
            },
          };
        }
      }

      const instance = new Subscribe("https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161");
    </script>
  </body>
</html>
